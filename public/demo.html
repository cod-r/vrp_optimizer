<!doctype html>
<html>
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"
          integrity="sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A=="
          crossorigin=""/>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css"
          integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
    <link rel="stylesheet" href="leaflet.css">
    <link href="https://use.fontawesome.com/releases/v5.0.4/css/all.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"
            integrity="sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA=="
            crossorigin=""></script>
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"
            integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo"
            crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js"
            integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49"
            crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js"
            integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy"
            crossorigin="anonymous"></script>
    <link rel="stylesheet" href="leaflet_awesome/leaflet.awesome-markers.css">
    <script src="leaflet_awesome/leaflet.awesome-markers.js"></script>
    <script src="leaflet.js"></script>

    <title>My Web Page</title>

</head>

<style>
    #mapid {
        height: 800px;
    }
</style>

<body>
<div id="mapid"></div>
<div>
    <button onclick="solveProblemForSelectedMarkers()">Solve problem for selected markers</button>
    <button onclick="solveHardCodedProblem()">Solve hard coded problem</button>
</div>

</body>

<script>
    const colors = ['blue', 'red', 'green', 'purple'];

    // initialize map
    let map = L.map('mapid').setView([44.432283, 26.104162], 15);
    L.tileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 18
    }).addTo(map);

    map.setZoom(13);

    map.on('click', function (e) {
        L.marker(e.latlng).addTo(map);

        getAddress(e.latlng)
            .then(address => addToAddressList(address.address));
    });

    // Reverse geocoding: get address from coordinates
    async function getAddress(latlng) {
        let nominatinApiUrl = "http://localhost:7070";

        return await fetch(nominatinApiUrl + "/reverse?lat=" + latlng.lat + "&lon=" + latlng.lng + "&format=jsonv2", {
            method: "GET"
        }).then(response => response.json());
    }

    async function addToAddressList(address) {
        if (!address.house_number) {
            address.house_number = '';
        } else {
            address.house_number = address.house_number + ', ';
        }

        let strippedAddress = address.road + ' '
            + address.house_number
            + address.city + ', '
            + address.postcode;

        console.log(strippedAddress);
        // TODO: add to the list of addresses in frontend

    }

    async function solveProblemForSelectedMarkers() {
        let markerLocations = [];
        let demands = [];
        let carsWithCapacity = [1000];

        // get coords from all markers from the map
        map.eachLayer(function (layer) {
            if (layer instanceof L.Marker) {
                markerLocations.push([layer.getLatLng().lng, layer.getLatLng().lat]);
            }
        });

        // Generate dummy demands TODO: get the demands from address list
        for (let i = 0; i < markerLocations.length; i++) {
            demands.push(1);
        }

        // call the openrouteservice api to get the distance matrix
        let distanceMatrix = await getDistanceMatrix(markerLocations);

        // add the demands and cars to the response from the distance matrix
        addDemands(distanceMatrix, demands);
        // TODO: get the capacities from the modal built by madalina
        addCars(distanceMatrix, carsWithCapacity);

        // send the distance matrix object to the Flask backend to calculate the routes
        const optimizedSolution = await getSolution(distanceMatrix);

        await showSolutionOnMapForSelectedMarkers(optimizedSolution);
    }

    async function showSolutionOnMapForSelectedMarkers(optimizedSolution) {
        // delete current markers so we can show the ones with numbers
        deleteAllMarkers();

        let cont = 0;

        for (const route of optimizedSolution.routes) {
            let locationsArray = [];
            let cont2 = 0;
            route.locations.forEach(location => {
                locationsArray.push(location.location)
                if (cont2 === 0) {
                    L.marker([
                            location.location[1],
                            location.location[0]
                        ]
                    ).addTo(map);
                } else if (route.locations.length > cont2 + 1) {

                    let coloredMarkerIcon = L.AwesomeMarkers.icon({
                        icon: '',
                        prefix: 'fa',
                        markerColor: colors[cont],
                        html: cont2
                    });
                    L.marker([
                            location.location[1],
                            location.location[0]
                        ],
                        {icon: coloredMarkerIcon}
                    ).addTo(map);
                }
                cont2++;
            })

            let vehicleRoute = await getDirections(locationsArray);

            let path = L.geoJSON(vehicleRoute);

            path.setStyle({
                color: colors[cont]
            });
            map.addLayer(path);

            cont++;
        }
    }

    function deleteAllMarkers() {
        map.eachLayer(function (layer) {
            if (layer instanceof L.Marker) {
                layer.remove();
            }
        });
    }

    async function showSolutionOnMap(optimizedSolution) {
        let cont = 0;

        for (const route of optimizedSolution.routes) {
            let locationsArray = [];
            let cont2 = 0;
            route.locations.forEach(location => {
                locationsArray.push(location.location)
                if (cont2 === 0) {
                    L.marker([
                            location.location[1],
                            location.location[0]
                        ]
                    ).addTo(map);
                } else if (route.locations.length > cont2 + 1) {

                    let coloredMarkerIcon = L.AwesomeMarkers.icon({
                        icon: '',
                        prefix: 'fa',
                        markerColor: colors[cont],
                        html: cont2
                    });
                    L.marker([
                            location.location[1],
                            location.location[0]
                        ],
                        {icon: coloredMarkerIcon}
                    ).addTo(map);
                }
                cont2++;
            })

            let vehicleRoute = await getDirections(locationsArray);

            let path = L.geoJSON(vehicleRoute);

            path.setStyle({
                color: colors[cont]
            });
            map.addLayer(path);

            cont++;
        }
    }

    async function getDirections(coordinates) {
        let directionsApiUrl = "http://localhost:8080/ors/v2/directions/driving-car/geojson";

        return await fetch(directionsApiUrl, {
            method: "POST",
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({coordinates: coordinates})
        }).then(response => response.json());
    }

    // Solving the problem
    async function solveHardCodedProblem() {
        // first address is the depot
        let addresses = [
            "Str. Sinaia 18, bucuresti",
            "Aleea magura vulturului 7",
            "Constantin Budisteanu 20",
            "Aleea Ilioara 3"
        ];
        // the weight (demand) of the package for each address destination (todo: maybe include this in the addresses object)
        // first is the depot so the value is 0
        let demands = [0, 3, 5, 1];
        // we have two cars each having a capacity of 5
        let carsWithCapacity = [5, 5];

        // get the polar coordinates (lat, lng) from the nominatim api
        let nominatimResponses = addresses.map(address => getCoordinates(address));
        const nominatimObjects = await Promise.all(nominatimResponses);

        // extract the lat/lng from each nominatim query response and map them in an object required by the distance matrix
        // e.g {"locations":[[26.1347683,44.4443487],[26.1604182,44.4125858],[26.0901043,44.4433876]]}
        let locations = nominatimObjects
            .flat(1)
            .map(object => [object.lon, object.lat]);

        // call the openrouteservice api to get the distance matrix
        let distanceMatrix = await getDistanceMatrix(locations);

        // add the demands and cars to the response from the distance matrix
        addDemands(distanceMatrix, demands);
        addCars(distanceMatrix, carsWithCapacity);

        // send the distance matrix object to the Flask backend to calculate the routes
        const optimizedSolution = await getSolution(distanceMatrix);

        showSolutionOnMap(optimizedSolution)
        console.log(optimizedSolution);
    }

    async function getCoordinates(address) {
        let nominatinApiUrl = "http://localhost:7070";

        return await fetch(nominatinApiUrl + "/search?q=" + address + "&format=jsonv2", {
            method: "POST"
        }).then(response => response.json());
    }

    async function getDistanceMatrix(locations) {
        let matrixApiUrl = "http://localhost:8080/ors/v2/matrix/driving-car";

        return await fetch(matrixApiUrl, {
            method: "POST",
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({locations: locations})
        }).then(response => response.json());
    }

    function addDemands(distanceMatrix, demands) {
        // add the demands of each location in the response received from the distance matrix api
        // the demands are added in the metadata.query.locations object
        for (let i = 0; i < demands.length; i++) {
            distanceMatrix.metadata.query.locations[i] = {
                location: distanceMatrix.metadata.query.locations[i],
                demand: demands[i]
            };
        }

    }

    function addCars(distanceMatrix, carsWithCapacity) {
        distanceMatrix.metadata.cars = carsWithCapacity;
    }

    async function getSolution(distanceMatrix) {
        console.log(distanceMatrix);
        return fetch("http://localhost:5001/api/cvrp", {
            method: "POST",
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(distanceMatrix)
        }).then(response => response.json());
    }

</script>